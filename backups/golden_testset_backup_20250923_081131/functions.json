{
  "update_updated_at_column": "CREATE OR REPLACE FUNCTION public.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n$function$\n",
  "format_version": "CREATE OR REPLACE FUNCTION public.format_version(major integer, minor integer, patch integer, label character varying DEFAULT NULL::character varying)\n RETURNS character varying\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nBEGIN\n    IF label IS NULL OR label = '' THEN\n        RETURN format('%s.%s.%s', major, minor, patch);\n    ELSE\n        RETURN format('%s.%s.%s-%s', major, minor, patch, label);\n    END IF;\nEND;\n$function$\n",
  "parse_version": "CREATE OR REPLACE FUNCTION public.parse_version(version_string character varying)\n RETURNS TABLE(major integer, minor integer, patch integer, label character varying)\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nDECLARE\n    parts TEXT[];\n    version_part TEXT;\n    label_part TEXT;\nBEGIN\n    -- Split on '-' to separate version from label\n    parts := string_to_array(version_string, '-');\n    version_part := parts[1];\n\n    IF array_length(parts, 1) > 1 THEN\n        label_part := parts[2];\n    ELSE\n        label_part := NULL;\n    END IF;\n\n    -- Parse version numbers\n    parts := string_to_array(version_part, '.');\n\n    IF array_length(parts, 1) >= 3 THEN\n        major := parts[1]::INT;\n        minor := parts[2]::INT;\n        patch := parts[3]::INT;\n        label := label_part;\n        RETURN NEXT;\n    ELSE\n        RAISE EXCEPTION 'Invalid version format: %', version_string;\n    END IF;\nEND;\n$function$\n",
  "compare_versions": "CREATE OR REPLACE FUNCTION public.compare_versions(v1_major integer, v1_minor integer, v1_patch integer, v2_major integer, v2_minor integer, v2_patch integer)\n RETURNS integer\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nBEGIN\n    IF v1_major > v2_major THEN RETURN 1;\n    ELSIF v1_major < v2_major THEN RETURN -1;\n    ELSIF v1_minor > v2_minor THEN RETURN 1;\n    ELSIF v1_minor < v2_minor THEN RETURN -1;\n    ELSIF v1_patch > v2_patch THEN RETURN 1;\n    ELSIF v1_patch < v2_patch THEN RETURN -1;\n    ELSE RETURN 0;\n    END IF;\nEND;\n$function$\n",
  "get_latest_testset_version": "CREATE OR REPLACE FUNCTION public.get_latest_testset_version(testset_name character varying)\n RETURNS TABLE(id uuid, name character varying, version_string character varying, status character varying, created_at timestamp with time zone)\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT\n        t.id,\n        t.name,\n        format_version(t.version_major, t.version_minor, t.version_patch, t.version_label),\n        t.status,\n        t.created_at\n    FROM golden_testsets t\n    WHERE t.name = testset_name\n    ORDER BY t.version_major DESC, t.version_minor DESC, t.version_patch DESC, t.created_at DESC\n    LIMIT 1;\nEND;\n$function$\n",
  "get_testset_stats": "CREATE OR REPLACE FUNCTION public.get_testset_stats(testset_uuid uuid)\n RETURNS TABLE(total_examples integer, avg_context_precision numeric, avg_context_recall numeric, avg_faithfulness numeric, avg_answer_relevancy numeric, retrieval_strategies text[])\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT\n        COUNT(*)::INT as total_examples,\n        ROUND(AVG(e.context_precision), 2) as avg_context_precision,\n        ROUND(AVG(e.context_recall), 2) as avg_context_recall,\n        ROUND(AVG(e.faithfulness), 2) as avg_faithfulness,\n        ROUND(AVG(e.answer_relevancy), 2) as avg_answer_relevancy,\n        array_agg(DISTINCT e.retrieval_strategy) as retrieval_strategies\n    FROM golden_examples e\n    WHERE e.testset_id = testset_uuid;\nEND;\n$function$\n",
  "validate_version_progression": "CREATE OR REPLACE FUNCTION public.validate_version_progression()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    latest_version RECORD;\nBEGIN\n    -- Get the latest version for this testset\n    SELECT version_major, version_minor, version_patch\n    INTO latest_version\n    FROM golden_testsets\n    WHERE name = NEW.name\n    ORDER BY version_major DESC, version_minor DESC, version_patch DESC\n    LIMIT 1;\n\n    -- If this is the first version, allow it\n    IF latest_version IS NULL THEN\n        RETURN NEW;\n    END IF;\n\n    -- Allow same version for idempotent operations (will be handled by unique constraint)\n    IF compare_versions(NEW.version_major, NEW.version_minor, NEW.version_patch,\n                       latest_version.version_major, latest_version.version_minor, latest_version.version_patch) < 0 THEN\n        RAISE EXCEPTION 'New version %.%.% must be greater than or equal to latest version %.%.%',\n            NEW.version_major, NEW.version_minor, NEW.version_patch,\n            latest_version.version_major, latest_version.version_minor, latest_version.version_patch;\n    END IF;\n\n    RETURN NEW;\nEND;\n$function$\n"
}